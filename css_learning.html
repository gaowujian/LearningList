<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h1>选择器</h1>
    <h2>基本规则</h2>
    <p>css的一个核心特性就是可以向一组元素应用某些规则</p>
    <p>基本规则的组成是由：选择器（selector）和声明块（declaration block），声明块是由多个声明组成的，每个生命都是一个属性一值对（property-value）,
        属性值对之间需要用; 隔开， 对于每一个属性的值 可以存在多个关键字，关键字之间需要用空格隔开  margin: 15px 10px
    </p>
    <h2>分组(包括对选择器的分组，也包括对声明的分组)</h2>
    <p>常见的选择器</p>
    <h3>通配选择器</h3>
    <p>这个选择器和文档语言中的所有元素名匹配。如果规则没有显示指定选择器，则可以认为是通配选择器</p>
    <p>模式: *</p>
    <p>示例 *{color:red}</p>
    <h3>类型选择器（元素选择器）</h3>
    <p>这个选择器和文档语言中的一个元素名匹配。该元素的每一个实例都与之匹配</p>
    <p>模式: element1</p>
    <p>示例 p{font-size:1em}</p>
    <h3>后代选择器</h3>
    <p>后代选择器允许创作人员根据元素的状态(即作为另一个元素的后代)来选择该元素。与之匹配的元素可以使祖先元素的子元素，孙元素，曾孙元素等等</p>
    <p>模式:element1 element2</p>
    <p>示例 body h1{font-size:200%}</p>
    <h3>子元素选择器</h3>
    <p>比后代选择器更严格，只选择子元素</p>
    <p>模式: element1 > element2</p>
    <p>示例 div > P{color:cyan}</p>
    <h3>相邻兄弟选择器</h3>
    <p>允许开发人员选择元素的下一个相邻兄弟，不包括该元素之前的兄弟,元素之间的文本会省略，只考虑文档树中的元素及其位置</p>
    <p>模式: element1 + element2</p>
    <p>示例: table + p {margin-top: 2.5em}</p>
    <h3>类选择器</h3>
    <p>用于选取有特定类值的元素，类值名必须跟在点号后面。多个类值可以连在一起。如果类值前没有元素，这个选择器将和所有包含该值的元素匹配</p>
    <p>模式: element1.className1  element2.className1.className2</p>
    <p>示例: p.urgent{color:red} p.urgent.warning{color:cyon}</p>
    <h3>ID选择器</h3>
    <p>用于选择有某个或特定ID值的元素，ID值必须跟在一个#之后.如果类值前没有元素，这个选择器将和所有包含该值的元素匹配</p>
    <p>模式:element1#idname</p>
    <p>示例: h1#page-title{font-size:200%}</p>
    <h3>简单属性选择器</h3>
    <p>允许根据属性的存在来选择元素，不关心属性的值时什么</p>
    <p>模式: element[attr]</p>
    <p>示例：a[rel]{border-bottom: 3 double gray}</p>
    <h3>具体属性选择器</h3>
    <p>根据属性的具体值来选择元素,必须是完美匹配，例如下面的class的例子，元素的class必须完全等于urgent，不能多也不能少</p>
    <p>模式: element[attr='value']</p>
    <p>示例: a[rel='Home']{font-weight:bold} p[class='urgent']{}</p>
    <h3>部分属性值选择器</h3>
    <p>允许根据属性值的一部分选择元素，有的属性可能存在多个值，例如class</p>
    <p>模式：element1[attr~='value']</p>
    <p>p[class~='warning']{background:'yellow'}</p>
    <h2>伪类和伪元素</h2>
    <p>会根据某种条件而不是文档结构向文档中的默写部分应用样式，而且无法通过研究文档的标记准确判断出采取何种方式来应用样式</p>
    <h3>伪类选择器</h3>
    <p>拿a标签作为例子，a有两种类型，已访问的和未访问的，这些类型都称作伪类(pseudo-class), 使用这些伪类的选择器都是伪类选择器(pseudo-class selector)</p>
    <p>CSS2定义了两个伪类，被称为超链接 link 和  visited</p>
    <ul>
        <li>:link指向了所有作为超链接(即有href属性)并未访问的锚</li>
        <li>:visited执行了所有已经访问的锚</li>
    </ul>
    <p>Css3定义了三个伪类，被称为动态伪类 foucs hover active</p>
    <ul>
        <li>:focus：指向所有拥有输入焦点的元素，可以接受键盘输入或者能以某种方式激活的元素</li>
        <li>:hover: 指向鼠标指针停留的元素，如果指针停留在一个超链接，那么a:hover就会指示这个超链接</li>
        <li>:active: 指向被用户激活的元素，例如鼠标停留在一个超链接，点击鼠标就会变成active，点击完之后会变成visited</li>
    </ul>
    <p>css还定义了一些静态伪类 first-child (选择一个标签，且这个标签是他所有兄弟节点中的第一个，即父元素的第一个节点)</p>
    <ul>
        <li>:first-child选择第一个子元素 <br>
        p:first-child注意该元素是选中了讲p作为第一个元素的所有元素，而不是在p元素下寻找第一个子元素 <br>
        示例 div ul li:first-child 可以选择div 中的ul中li， 选中的li是ul下的第一个元素
        </li>
    </ul>
    <h3>伪元素选择器</h3>
    <p>常用的两个是first-letter和first-line用于执行元素内的第一个子母和第一行内容</p>
    <h4>伪类伪元素的区别</h4>
    <blockquote>The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors.</blockquote>
    <p>伪类的引入提供了更好的选择机制，该机制不是基于文档树的结构，实现了通过之前的简单选择器不能实现的选择</p>
    <blockquote>
    Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element's content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document (e.g., the ::before and ::after pseudo-elements give access to generated content).
    </blockquote>
    <p>伪元素提供了由文档语言表明的文档树之上的抽象，例如文档语言无法获取一个元素内容的第一个元素或者第一行，通过伪元素可以实现。伪元素还给开发者提供了一种指向源文档中并不存在的内容的方式，即::before和::after</p>
    <p>伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息。而伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式。</p>
    <p>在CSS3中，伪类用单冒号:表示；而伪元素用双冒号::表示。一个选择器可以同时使用多个伪类(但有的伪类会互斥)；而一个选择器只能同时使用一个伪元素(未来的版本可能会支持多伪元素)。</p>
    <h1>结构和层叠</h1>
    <h2>特殊性</h2>
    <p>元素有多个属性的冲突声明时，最高特殊性的声明会胜出</p>
    <ul>
        <li>ID属性选择器 特殊性 0100</li>
        <li>类选择器和属性选择器，以及伪类选择器 特殊性 0010</li>
        <li>元素和伪元素选择器 特殊性 0001</li>
        <li>结合符和通配符不做任何贡献</li>
        <li>内联属性的赋值 特殊性 1000</li>
        <li>设置了important的声明被称作重要声明，非重要声明之间使用特殊性来判断生出，但是重要声明和非重要声明相比总会获胜,这不再是特殊性，而且显示权重比较高</li>
    </ul>
    <h2>继承性</h2>
    <p>基于继承机制，样式不仅应用于指定样式，还应用于子元素</p>
    <p>继承是css的基础内容之一，一般不用去必要考虑，但是有几点需要注意</p>
    <ul>
        <li>有些属性不能继承，往往基于一些简单的常识。大多数的框模型属性都不能继承，例如外边距，内边距，背景和边框. <br>
        继承的值并没有特殊性，即使是0的特殊性也没有，可以参考下边的这个例子
                <!-- <h1 id='page'>Market <em>central</em> </h1>
                <p>welcome to dsfwer nhfe</p>
                <style>
                    * {
                        color:gray
                    }
                    h1#page{
                        color: black
                    }
                </style> -->
        </li>
    </ul>
    <h2>层叠</h2>
    <p>CSS（层叠样式表）就是让样式层叠在一起，通过结合特殊性和继承性来做到</p>
    <p>层叠规则:</p>
    <ol>
        <li>找到所有的规则，规则都包含一个与一个给定元素匹配的选择器</li>
        <li>按显示权重，针对一个元素的所有声明进行排序，有important的声明比没有的高;按来源，针对一个元素的所有声明进行排序，author (程序员编写)> reader（浏览用户） > user agent（浏览器默认样，但是有important的reader比有important的author要高，举例就是可以在chrome中直接修改查看效果</li>
        <li>按特殊性,针对声明排序，特殊性越高，权重越大</li>
        <li>按出现顺序，针对声明排序，越靠后，权重越大</li>
    </ol>
    <p>针对于后三条原则加以详述</p>
    <h3>按权重和来源排序</h3>
    <p>在声明权重的时候有一个排序, 程序员其实只需要考虑前四个级别</p>
    <ol>
        <li>读者的重要声明</li>
        <li>创作人员的重要声明</li>
        <li>创作人员的正常声明</li>
        <li>读者的正常声明</li>
        <li>用户代理声明</li>
    </ol>
    <h3>按特殊性排序</h3>
    <p>计算特殊性的值，然后根据大小添加样式</p>
    <h3>按出现的先后顺序排序</h3>
    <p>在有一些情况下，特殊性是一样的，我们需要按照先后顺序，重要的一点事a的伪类选择器添加样式</p>
    <p>因为a:link, a:visited, a:hover, a:active都是享有相同的特殊性都是 0011, 元素+伪类，所以当点击一个超链接的时候link, hover, active三种
        状态都被触发，定义时候的先后顺序就尤为重要，常用的就是link,hover,active, 同时一个a标签的状态只有点击过和没点击过，如果放在hover之后，那么
        hover的状态永远不会出线，所以link和visited都放在hover之前，所以最常用的定义顺序就是，link, visited, hover, active (即LVHA)
    </p>
    <h1>值和单位</h1>
    <h2>Keywords, string and other text values</h2>
    <h3>global keywords</h3>
    <ul>
        <li>inherit: (值和父元素的值相同)The keyword inherit makes the value of a property on an element the same
                as the value of that property on its parent element</li>
        <li>initial: (设置为初始值，每一个属性其实都有自己的初始值)The keyword initial sets the value of a property to the defined initial value,
                which in a way means it “resets” the value. </li>
        <li>unset:(如果属性可继承，那么就等同于inherit，否则等同于initial)The keyword unset acts as a universal stand-in for both inherit and ini
                tial</li>
    </ul>
    <h3>url</h3>
    <p>css中引入url的正确语法:  url(protocol://server/pathname)</p>
    <h2>distance</h2>
    <h3>Absolute length units绝对长度单位</h3>
    <ol>
        <li>inches(in)</li>
        <li>centimeters(cm)</li>
        <li>millimeters(mm)</li>
        <li>quarter-millimeters(p)</li>
        <li>points(pt):打印机常用</li>
        <li>picas(pc)</li>
        <li>pixel(px)</li>
    </ol>
    <p>网页的展示取决于屏幕大小和分辨率大小，所以以上的单位不建议使用，除非你知道会在何种环境下使用</p>
    <h3>relative length units 相对长度单位</h3>
    <ol>
        <li>em:  “em” is defined to be the value of font-size for a given font. In theory, one em is equal to the width of a lowercase m in the font used</li>
        <li>ex: In theory, one ex is equal to the height of a lowercase x in the font used</li>
        <li>rem:  the rem unit is based on declared font size, using the root element(html)</li>
        <li>ch: </li>
        <li>vw: (Viewport width unit)divided by 100. Therefore, if the viewport is 937 pixels wide, 1vw is equal to 9.37px</li>
        <li>vh:(Viewport width unit)</li>
        <li>vmin:(Viewport minimum unit) 1000px宽 500px高 那么1vmin是5px</li>
        <li>vmax:(Viewport maximum unit) 1000px宽 500px高 那么1vmin是10px</li>
    </ol>
    <h2>calculation values</h2>
    <p>我们可以使用calc()函数进行长度的计算，可以计算长度，时间，频率，角度，时间，百分比，数字和整数</p>
    <h2>attribute values</h2>
    <p>针对一些css的属性，有时候需要用html的属性值，例如 p::before {content: "[" attr(id) "]";} 会在所有p段落前加上p标签的id值    &lt; p id="leadoff" &gt; This is the first paragraph. &lt;/p &gt; 会变成  [leadoff]This is the first paragraph. </p>
    <h2>color</h2>
    <p>我们有148种已定义的颜色，还有RGB,RGBA,HSL和HSLA 等不同方式定义颜色</p>
    <p>我们还有两个color的关键字，可以用在填写颜色的地方，他们是transparent和currentColor(copy color属性的值)</p>
    <h2>angles</h2>
    <p>我们有四种方式定义角度</p>
    <ul>
        <li>deg, 360组成一圈,eg 270 deg</li>
        <li>grad, 400组成一圈, eg 300 grad</li>
        <li>rad, 2π组成一圈, eg0.785 rad</li>
        <li>turn, 1表示一圈，在制作动画旋转的时候尤其有用,10turn表示旋转10圈</li>
    </ul>
    <h2>time and frequency</h2>
    <p>a[href] {transition-duration: 2.4s;} 主要有两个单位s和ms</p>
    <p>h1 {pitch: 128hz;} 频率主要有hz</p>
    <h2>position</h2>
    <h2>custom values</h2>
    <pre>
html {
    --alison: #639;
    --david: #AEA;
    }
    h1 {color: var(--alison);}
    </pre>
    <p>在html内中声明了一个变量，自定义变量需要--开头，在调用的时候通过var关键字，区分大小写</p>
    <h1>字体</h1>
    <h2>字体系列 font-family</h2>
    <p>有五种通用字体</p>
    <ol style="font-size:18px">
        <li style="font-family: serif">serif：成比例有上下短线,短线指的是字符比划末端的装饰，例如f和l的小尾巴</li>
        <li style="font-family: sans-serif">sans-serif：成比例没有上下短线</li>
        <li style="font-family: monospace">monospace：不成比例，每个字符的长度基本相同</li>
        <li style="font-family: cursive">cursive:模仿人的手写体</li>
        <li style="font-family: fantasy;">fantasy:无任何特征定义</li>
    </ol>
    <p>注意font-family字体属性，如果字体名有空格，需要使用引号将字体名括起来，例如 'Times New Roman'</p>
    <h2>字体加粗 font-weight</h2>
    <p>通过设置font-family也可以实现加粗的效果例如TimesBold</p>
    <p>关键字:100-900,  100-400反映了较细变细， 500，600对应较粗， 700，800，900对应了很粗的字体</p>
    <p>400对应了normal，700对应了bold</p>
    <h2>字体大小 font-size</h2>
    <h2>字体风格 font-style</h2>
    <ul>
        <li style="font-style: normal">使用normal的文本</li>
        <li style="font-style: italic">使用italic的文本，斜体</li>
        <li style="font-style: oblique">使用oblique的文本，倾斜文本</li>
    </ul>
    <p>italic和oblique的区别:他们都是让字体具有倾斜的效果，italic是字体自带的斜体属性，oblique是使字体向右倾斜。但是，并不是所有字体都具有斜体的样式，对于那些没有斜体样式的字体来说，使用italic是没有效果的，此时就可以利用oblique代替italic来实现字体倾斜的效果啦。</p>
    <h2>字体变形 font-variant</h2>
    <ul style="font-size:18px">
        <li style="font-variant: normal">使用normal的文本</li>
        <li style="font-variant: small-caps">使用Small-caps的文本，使用小型大写字母文本</li>
    </ul>
    <p>font主要有5个属性:font-family, font-weight, font-size, font-style, font-variant， 其实还有另外一个属性line-height，虽然他是一个text属性而不是font属性</p>
    <p>简写font属性: font-style | font-variant | font-weight | font-size | line-height | font-family</p>
    <p>可以使用关键字给font属性添加设置:</p>
    <ul style="font-size:18px">
        <li style="font:caption">caption:有标题的空间</li>
        <li style="font:icon">icon：对图标添加标签</li>
        <li style="font:menu">menu：用于菜单，即下拉菜单列表</li>
        <li style="font:message-box">message-box:用于对话框</li>
        <li style="font:small-caption">用于对小控件添加标签</li>
        <li style="font:status-bar">用于窗口状态条</li>
    </ul>
    <h1>文本属性</h1>
    <p>首先的是区分文本和字体:文本就是内容，而字体用于显示这个内容</p>
    <h2>文本缩进 text-indent</h2>
    <p>有很多种实现方式，有的网站在文本前放一个透明图形，有的网站采用完全非标准的spacer标记 例如 &nbsp</p>
    <p>text-indent只用于块级元素，而不能用于行内元素，行内元素通过设置内边距和外边距实现缩进</p>
    <h2>水平对齐 text-align</h2>
    <p>主要有三个值:left,right,center, 新增的justfy可以将内容平均分配在一行之内</p>
    <h2>inline alignment 行内对齐</h2>
    <h3>the height of lines</h3>
    <p>line-height指的是不同文本基线之间的距离，而不是字体的大小</p>
    <h4>一行的组成部分</h4>
    <img src="./images/constructureOfAline.png" alt="constructuing a line" >
    <p>line-height实际上控制的是leading 行间距</p>
    <h4>assign values to line-height</h4>
    <p>一般来说user agent设置的是1.2倍的font-size</p>
    




    <h1>Basic visual formatting</h1>
    <h2>Basic box 盒子模型</h2>
    <h3>A quick refresher</h3>
    <dl>
        <dt>normal flow</dt>
        <dd>从左到右，从上到下的西文文本渲染 和相似的html文档的文本布局渲染 联合称为normal flow. 一个元素脱离normal flow的方法有
                floated，positioned或者是放于一个flexible box或grid 布局元素中</dd>
        <dt>nonreplaced element</dt>
        <dd>元素的内容存在于文档流中的的元素，例如p</dd>
        <dt>replaced element</dt>
        <dd>元素冲淡了一个占位的作用，例如img</dd>
        <dt>root element</dt>
        <dd>根元素，在html文档当中，这个元素就是html标签</dd>
        <dt>block box</dt>
        <dd>块盒子在normal flow中垂直叠加，任何元素都可以用来创建一个块盒子，通过设置display:block</dd>
        <dt>inline box</dt>
        <dd>行内盒子不会在盒子前后创建换行，通过设置display:inline</dd>
        <dt>inline-block box</dt>
        <dd>行内块壳子，对内表现是块盒子，对外表现是行内盒子</dd>
    </dl>
    <p>还有一些其他的盒子模型，包括table-cell boxes，因为这些盒子很复杂 本身就需要一本书来解释，尽量不使就好了</p>
    <h3>Containning block</h3>
    <p>the containing block forms from the content edge of the nearest ancestor that generated a list item or block box</p>
    <p>容器块由最近的祖先模块的内容区域生成，且这个祖先有一个list元素或者块元素，html是最初是的容器块</p>
    <h2>altering element display</h2>
    <h3>changing roles 改变角色</h3>
    <p>需要注意的是，改变元素的display属性并不能改变他们内在的本质，换句话说，一个p标签创建了一个inline box并不意味着他就是一个行内元素</p>
    <p>块元素可以包含行内元素，但是反过来往往不能，display只是改变了他们的展示方式，但是不能改变行内元素不能放块元素的本质</p>
    <h3>block boxes</h3>
    <p>box-sizing:适用于一切接受height和width值的元素，主要是块元素，不过也同样适用于行内元素例如img，和inline-block元素</p>
    <p>this property is how you change what the width and height values actually do</p>
    <p>content-box  The width and height properties (and min/max properties) includes only the content.</p>
    <p>border-box	The width and height properties (and min/max properties) includes content, padding and border</p>
    <h3>horizontal formatting</h3>
    <p>水平方向格式化通常比我们想想的要复杂，因为box-sizing</p>
    <p>外部元素的content area的宽度，等于子元素的content area + padding + border + margin</p>
    <p>上边的原则不会变，永远是以父元素的内容区域为基准，改变display只是改变了当前元素的width组成，是否包含padding和border</p>
    <h3>horizontal property</h3>
    <p>7个水平属性包括, margin-left, border-left, padding-left, width, padding-right, border-right, margin-right</p>
    <p>其中只有3个值可以设置为auto，包括width,margin-left和margin-right，其他的四个属性必须设置值或者默认为0</p>
    <h3>using auto</h3>
    <p>有一种情况，当padding,border保持默认为0，width,margin-left和margin-right设为固定值，但是加起来的width不等于父元素的content width，
        这种情况下属于过度限制，margin-right的值会被强制设成auto。事实上，不仅是这种情况，当出现任何过度限制的情况下,margin-right都会被
        设置成auto来满足 7个属性的和等于父元素content area宽度的等式
    </p>
    <h3>more than one auto</h3>
    <p>如果两个margin是auto,且父元素子元素的width固定，那么子元素会被居中显示</p>
    <p>如果是width和一个margin设为auto，设置了一个margin为固定值，那么设为auto的margin值会自动转为0，width长度会填满剩余区域</p>
    <p>如果三个值都是auto呢，那么margin值会被设置为0，width值会填满containing block</p>
    <p>水平方向的padding，margin不会合并</p>
    <h3>negative margin</h3>
    <p>margin可以设置为负值来实现某些有趣的效果，但是padding，border和width永远不可以设置为负值</p>
    <h3>percentages</h3>
    <p>当7属性中，有不同的赋值方式，百分比，长度值等等，会有一些tricky的事情发生，margin-right总会处理到位</p>
    <p>border不接受百分比</p>
    <h3>replaced elements</h3>
    <p>可替换元素比不可替换元素甚至更好管理，只有一点不同，例如对于img来说，如果width设置成auto的话，那么img的width默认就是图片的大小</p>
    <p>图片的height会根据width的变化同比例变化，如果设置了固定值，那就会按照固定值显示</p>
    <h3>vertical formatting</h3>
    <p>默认等于可见元素加起来的高度，可以设置固定值，如果大于子元素，会出现padding的效果，如果小于，会出现overflow的默认滚动效果</p>
    <h3>vertical property</h3>
    <p>同样是由7个属性组成, margin-top, border-top, padding-top, height, padding-bottom, border-bottom, margin-bottom</p>
    <h3>percentage height</h3>
    <p>当margin-top和margin-bottom设置为auto的时候，他们会自动等于0，所以不能通过设置auto的方式达到垂直居中的效果</p>
    <p>在这种情况下，一种比较的方式就是，显式设置margin-top和margin-bottom的值，使他们相等，同时给height赋值</p>
    <p>但是如果父节点的height没有设置的话，percentage设为auto会自动转为0，因为默认来说父元素的height是子元素累加而来，如果不提前设定好，
        而子元素想用percentage设置高度的话，是找不到依据的
    </p>
    <div style="height: 6em;">
        <p style="height: 50%">Half as tall</p>
    </div>
    <h3>collapsing vertical margins</h3>
    <p>垂直margin会有合并的效果，当negative margin合positive margin相遇时，不会合并，而是进行想加减</p>
    <h2>inline elements</h2>
    <h3>line layout</h3>
    <p></p>
</body>
</html>