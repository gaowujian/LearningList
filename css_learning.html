<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h1>选择器</h1>
    <h2>基本规则</h2>
    <p>css的一个核心特性就是可以向一组元素应用某些规则</p>
    <p>基本规则的组成是由：选择器（selector）和声明块（declaration block），声明块是由多个声明组成的，每个生命都是一个属性一值对（property-value）,
        属性值对之间需要用; 隔开， 对于每一个属性的值 可以存在多个关键字，关键字之间需要用空格隔开  margin: 15px 10px
    </p>
    <h2>分组(包括对选择器的分组，也包括对声明的分组)</h2>
    <p>常见的选择器</p>
    <h3>通配选择器</h3>
    <p>这个选择器和文档语言中的所有元素名匹配。如果规则没有显示指定选择器，则可以认为是通配选择器</p>
    <p>模式: *</p>
    <p>示例 *{color:red}</p>
    <h3>类型选择器（元素选择器）</h3>
    <p>这个选择器和文档语言中的一个元素名匹配。该元素的每一个实例都与之匹配</p>
    <p>模式: element1</p>
    <p>示例 p{font-size:1em}</p>
    <h3>后代选择器</h3>
    <p>后代选择器允许创作人员根据元素的状态(即作为另一个元素的后代)来选择该元素。与之匹配的元素可以使祖先元素的子元素，孙元素，曾孙元素等等</p>
    <p>模式:element1 element2</p>
    <p>示例 body h1{font-size:200%}</p>
    <h3>子元素选择器</h3>
    <p>比后代选择器更严格，只选择子元素</p>
    <p>模式: element1 > element2</p>
    <p>示例 div > P{color:cyan}</p>
    <h3>相邻兄弟选择器</h3>
    <p>允许开发人员选择元素的下一个相邻兄弟，不包括该元素之前的兄弟,元素之间的文本会省略，只考虑文档树中的元素及其位置</p>
    <p>模式: element1 + element2</p>
    <p>示例: table + p {margin-top: 2.5em}</p>
    <h3>类选择器</h3>
    <p>用于选取有特定类值的元素，类值名必须跟在点号后面。多个类值可以连在一起。如果类值前没有元素，这个选择器将和所有包含该值的元素匹配</p>
    <p>模式: element1.className1  element2.className1.className2</p>
    <p>示例: p.urgent{color:red} p.urgent.warning{color:cyon}</p>
    <h3>ID选择器</h3>
    <p>用于选择有某个或特定ID值的元素，ID值必须跟在一个#之后.如果类值前没有元素，这个选择器将和所有包含该值的元素匹配</p>
    <p>模式:element1#idname</p>
    <p>示例: h1#page-title{font-size:200%}</p>
    <h3>简单属性选择器</h3>
    <p>允许根据属性的存在来选择元素，不关心属性的值时什么</p>
    <p>模式: element[attr]</p>
    <p>示例：a[rel]{border-bottom: 3 double gray}</p>
    <h3>具体属性选择器</h3>
    <p>根据属性的具体值来选择元素,必须是完美匹配，例如下面的class的例子，元素的class必须完全等于urgent，不能多也不能少</p>
    <p>模式: element[attr='value']</p>
    <p>示例: a[rel='Home']{font-weight:bold} p[class='urgent']{}</p>
    <h3>部分属性值选择器</h3>
    <p>允许根据属性值的一部分选择元素，有的属性可能存在多个值，例如class</p>
    <p>模式：element1[attr~='value']</p>
    <p>p[class~='warning']{background:'yellow'}</p>
    <h2>伪类和伪元素</h2>
    <p>会根据某种条件而不是文档结构向文档中的默写部分应用样式，而且无法通过研究文档的标记准确判断出采取何种方式来应用样式</p>
    <h3>伪类选择器</h3>
    <p>拿a标签作为例子，a有两种类型，已访问的和未访问的，这些类型都称作伪类(pseudo-class), 使用这些伪类的选择器都是伪类选择器(pseudo-class selector)</p>
    <p>CSS2定义了两个伪类，被称为超链接 link 和  visited</p>
    <ul>
        <li>:link指向了所有作为超链接(即有href属性)并未访问的锚</li>
        <li>:visited执行了所有已经访问的锚</li>
    </ul>
    <p>Css3定义了三个伪类，被称为动态伪类 foucs hover active</p>
    <ul>
        <li>:focus：指向所有拥有输入焦点的元素，可以接受键盘输入或者能以某种方式激活的元素</li>
        <li>:hover: 指向鼠标指针停留的元素，如果指针停留在一个超链接，那么a:hover就会指示这个超链接</li>
        <li>:active: 指向被用户激活的元素，例如鼠标停留在一个超链接，点击鼠标就会变成active，点击完之后会变成visited</li>
    </ul>
    <p>css还定义了一些静态伪类 first-child (选择一个标签，且这个标签是他所有兄弟节点中的第一个，即父元素的第一个节点)</p>
    <ul>
        <li>:first-child选择第一个子元素 <br>
        p:first-child注意该元素是选中了讲p作为第一个元素的所有元素，而不是在p元素下寻找第一个子元素 <br>
        示例 div ul li:first-child 可以选择div 中的ul中li， 选中的li是ul下的第一个元素
        </li>
    </ul>
    <h3>伪元素选择器</h3>
    <p>常用的两个是first-letter和first-line用于执行元素内的第一个子母和第一行内容</p>
    <h4>伪类伪元素的区别</h4>
    <blockquote>The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors.</blockquote>
    <p>伪类的引入提供了更好的选择机制，该机制不是基于文档树的结构，实现了通过之前的简单选择器不能实现的选择</p>
    <blockquote>
    Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element's content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document (e.g., the ::before and ::after pseudo-elements give access to generated content).
    </blockquote>
    <p>伪元素提供了由文档语言表明的文档树之上的抽象，例如文档语言无法获取一个元素内容的第一个元素或者第一行，通过伪元素可以实现。伪元素还给开发者提供了一种指向源文档中并不存在的内容的方式，即::before和::after</p>
    <p>伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息。而伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式。</p>
    <p>在CSS3中，伪类用单冒号:表示；而伪元素用双冒号::表示。一个选择器可以同时使用多个伪类(但有的伪类会互斥)；而一个选择器只能同时使用一个伪元素(未来的版本可能会支持多伪元素)。</p>
    <h1>结构和层叠</h1>
    <h2>特殊性</h2>
    <p>元素有多个属性的冲突声明时，最高特殊性的声明会胜出</p>
    <ul>
        <li>ID属性选择器 特殊性 0100</li>
        <li>类选择器和属性选择器，以及伪类选择器 特殊性 0010</li>
        <li>元素和伪元素选择器 特殊性 0001</li>
        <li>结合符和通配符不做任何贡献</li>
        <li>内联属性的赋值 特殊性 1000</li>
        <li>设置了important的声明被称作重要声明，非重要声明之间使用特殊性来判断生出，但是重要声明和非重要声明相比总会获胜,这不再是特殊性，而且显示权重比较高</li>
    </ul>
    <h2>继承性</h2>
    <p>基于继承机制，样式不仅应用于指定样式，还应用于子元素</p>
    <p>继承是css的基础内容之一，一般不用去必要考虑，但是有几点需要注意</p>
    <ul>
        <li>有些属性不能继承，往往基于一些简单的常识。大多数的框模型属性都不能继承，例如外边距，内边距，背景和边框. <br>
        继承的值并没有特殊性，即使是0的特殊性也没有，可以参考下边的这个例子
                <!-- <h1 id='page'>Market <em>central</em> </h1>
                <p>welcome to dsfwer nhfe</p>
                <style>
                    * {
                        color:gray
                    }
                    h1#page{
                        color: black
                    }
                </style> -->
        </li>
    </ul>
    <h2>层叠</h2>
    <p>CSS（层叠样式表）就是让样式层叠在一起，通过结合特殊性和继承性来做到</p>
    <p>层叠规则:</p>
    <ol>
        <li>找到所有的规则，规则都包含一个与一个给定元素匹配的选择器</li>
        <li>按显示权重，针对一个元素的所有声明进行排序，有important的声明比没有的高;按来源，针对一个元素的所有声明进行排序，author (程序员编写)> reader（浏览用户） > user agent（浏览器默认样，但是有important的reader比有important的author要高，举例就是可以在chrome中直接修改查看效果</li>
        <li>按特殊性,针对声明排序，特殊性越高，权重越大</li>
        <li>按出现顺序，针对声明排序，越靠后，权重越大</li>
    </ol>
    <p>针对于后三条原则加以详述</p>
    <h3>按权重和来源排序</h3>
    <p>在声明权重的时候有一个排序, 程序员其实只需要考虑前四个级别</p>
    <ol>
        <li>读者的重要声明</li>
        <li>创作人员的重要声明</li>
        <li>创作人员的正常声明</li>
        <li>读者的正常声明</li>
        <li>用户代理声明</li>
    </ol>
    <h3>按特殊性排序</h3>
    <p>计算特殊性的值，然后根据大小添加样式</p>
    <h3>按出现的先后顺序排序</h3>
    <p>在有一些情况下，特殊性是一样的，我们需要按照先后顺序，重要的一点事a的伪类选择器添加样式</p>
    <p>因为a:link, a:visited, a:hover, a:active都是享有相同的特殊性都是 0011, 元素+伪类，所以当点击一个超链接的时候link, hover, active三种
        状态都被触发，定义时候的先后顺序就尤为重要，常用的就是link,hover,active, 同时一个a标签的状态只有点击过和没点击过，如果放在hover之后，那么
        hover的状态永远不会出线，所以link和visited都放在hover之前，所以最常用的定义顺序就是，link, visited, hover, active (即LVHA)
    </p>
    <h1>值和单位</h1>
</body>
</html>