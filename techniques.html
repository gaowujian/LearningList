<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <title>Document</title>
    <style>
            pre{
                display: block;
                width:100%;
                background: rgb(225, 193, 189);
            }
            h1,h2,h3,h4,h5,h6{
                text-transform: capitalize
            }
        </style>
</head>
<body class="container">
    <h1>Chrome assignment of values</h1>
    <pre>
            let value = 3
                undefined
            value
                3
            console.log(value)
                3
                undefined
    </pre>
    <p>在运行chrome developer tool的时候， 当我们输入1，3，5行的代码的时候会出现其他结果，为什么会出现undefined，
        因为在chrome的环境之后，默认操作是执行这条statement，然后再return value，所以第一条执行完赋值，但是没有返回值就会返回undefined，
        第二条执行并没有效果，但是返回值就返回了3，第三条执行的时候会打印出3，但是返回值没有所以是undefined
    </p>
    <h1>关于width，padding和margin的问题</h1>
    <p>width的大小和margin没有关系</p>
    <p>当box-sizing的是content-box：时</p>
    <p>padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，
            即 ( Element width = width + border + padding )</p>
    <p>当box-sizing的是border-box：时</p>
    <p>padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也
        不会改变对象的实际宽度，即 ( Element width = width )</p>
    <h1>实现闭包</h1>
    <pre>
function outside(x) {
    function inside(y) {
        return x + y;
    }
    return inside;
    }
    fn_inside = outside(3); // Think of it like: give me a function that adds 3 to whatever you give
                            // it
    result = fn_inside(5); // returns 8
    
    result1 = outside(3)(5); // returns 8
    </pre>
    <p>注意当函数inside返回时，x被保留了.因为外部函数内的变量存在周期比外部函数执行周期长,仔细体会</p>
    <p>虽然outside函数已经执行结束，但是里边的变量x还在被inner函数所引用</p>
    <pre>
var createPet = function(name) {
    var sex;
    
    return {
        setName: function(newName) {
        name = newName;
        },
        
        getName: function() {
        return name;
        },
        
        getSex: function() {
        return sex;
        },
        
        setSex: function(newSex) {
        if(typeof newSex === 'string' && (newSex.toLowerCase() === 'male' || 
            newSex.toLowerCase() === 'female')) {
            sex = newSex;
        }
        }
    }
    }
    
    var pet = createPet('Vivie');
    pet.getName();                  // Vivie
    
    pet.setName('Oliver');
    pet.setSex('male');
    pet.getSex();                   // male
    pet.getName();                  // Oliver
    </pre>
    <p>非常经典的一个使用function创建object的实例</p>
    <p>保留了外部函数的name和sex变量，通过返回一个由内部函数作为值组成的对象可以对保留的变量进行访问</p>
    <h1>识别declaration, assignment 和initialization的区别</h1>
   <ul>
       <li>Declaration is not to declare "value" to a variable; it's to declare the type of the variable.</li>
       <li>Assignment is simply the storing of a value to a variable.</li>
       <li>Initialization is the assignment of a value to a variable at the time of declaration.(declaration + assignment)</li>
   </ul>
   <h1>自己实现js的继承机制</h1>
   <pre>
function Employee(name='tony',dept='it'){
    this.name = name
    this.dept = dept
    //必须使用this保证方法的指向，否则的话默认指向了windows对象
    this.run = function(){
        console.log('I love running')
    }
}

function Manager(){
    //apply方法使得Manager也可以有Employee的属性的方法
    Employee.apply(this)
    this.report = []
    
}

Manager.prototype = Object.create(Employee.prototype);
Manager.prototype.constructor = Manager;

var tony = new Manager();
tony.run()
   </pre>
   <h1>Callback</h1>
   <p>使用一个函数做为参数传入另一个函数，这样的函数叫做回调函数，回调函数的定义出现在外部函数调用的时候，外部函数的参数列表和函数体内只用callback变量替代s</p>
   <h2>why do we need call back?</h2>
   <p>you can’t just call one function after another and hope they execute in the right order.(因为可能会有需要等待回应的的异步操作) 
       Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.</p>
    
   <h1>Promise机制</h1>
   <h2>官方案例解析</h2>
   <a href="https://www.baidu.com/link?url=JRlqW4Qa51urq9ZSAZjhgMr3D72VPbXTV-gYBsOVZcyz3X8bg_vG21g5Ahw4f1EQRbKhZh-x3Ye6oiPHFxHLHrQLscjiflVW0vluFbxZf5ppqE01gH2uom5HaQGkZPaGq_ysvOsk4C7B2M5xIc5nhg32Tyz3r2TUAaUB-5BRxLE6LXR-eFnIZU2Rpz7r845W&wd=&eqid=aebc643d0001ecbe000000065ce5ea91">同时推荐廖雪峰博客，非常清晰</a>
   <a href="http://es6.ruanyifeng.com/#docs/promise">同时推荐廖雪峰博客，非常清晰</a>
   <pre>
new Promise((resolve, reject) => {
    console.log('Initial');

    resolve();
})
.then(() => {
    throw new Error('Something failed');
        
    console.log('Do this');
})
.catch(() => {
    console.log('Do that');
})
.then(() => {
    console.log('Do this, no matter what happened before');
});

代码解析：
(resolve, reject) => {
    console.log('Initial');

    resolve();
} 等同于一个test函数，所以相当于是new Promise(test)，这一步可以初始化一个Promise对象，并执行test函数
   </pre>
   <h1>Website security</h1>
   <a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps/Website_security">see more information</a>
    <h1>apply, call，bind</h1>
    <a href="https://medium.com/@omergoldberg/javascript-call-apply-and-bind-e5c27301f7bb">For details</a>
    <dl>
        <dt>bind</dt>
        <dd>The bind() method creates a new function that, when called, has its this keyword set to the provided value.</dd>
        <dd>var logPokemon = pokemonName.bind(pokemon); bind方法有返回值，将方法的this指针指向了被当做参数传入的对象</dd>
        <dt>apply</dt>
        <dd>The call() method calls a function with a given this value and arguments provided individually</dd>
        <dd>pokemonName.call(pokemon,'sushi', 'algorithms');  call方法没有返回值，方法的指针指向了被当做参数传入的对象</dd>
    </dl>
    <h2>difference</h2>
    <p>The only difference between how they work is that call() expects all parameters to be passed in individually, whereas apply() expects an array of all of our parameters. Example:</p>
    <pre>
var pokemon = {
    firstname: 'Pika',
    lastname: 'Chu ',
    getPokeName: function() {
        var fullname = this.firstname + ' ' + this.lastname;
        return fullname;
    }
};

var pokemonName = function(snack, hobby) {
    console.log(this.getPokeName() + ' loves ' + snack + ' and ' + hobby);
};

pokemonName.call(pokemon,'sushi', 'algorithms'); // Pika Chu  loves sushi and algorithms
pokemonName.apply(pokemon,['sushi', 'algorithms']); // Pika Chu  loves sushi and algorithms
    </pre>
    <p>The main differences between bind() and call() is that the call() method:</p>
    <ol>
        <li>Accepts additional parameters as well</li>
        <li>Executes the function it was called upon right away.</li>
        <li>The call() method does not make a copy of the function it is being called on.</li>
    </ol>
    <pre>
function add(x,y){
    return this.x+ this.y;
}

var obj = {
    x:18,
    y:20
}
//bind方法有返回值，只是先确认this指向，可以之后调用
var result = add.bind(obj)
console.log(result())
//call方法会立马执行
console.log(add.call(obj))
    </pre>
    <h1>new 操作符</h1>
    <p>构造函数和普通函数没有什么区别，只是为了区分所以将函数名的开头字母大写</p>
    <ol>
        使用new操作符会经历以下几步:
        <li>创建一个新对象</li>
        <li>将构造函数的作用域赋给了新对象(所以this就指向了这个新对象，当该函数被当做普通函数调用时，调用时this指针会默认指向window对象)</li>
        <li>执行构造函数内的代码(给对象添加属性)</li>
        <li>返回一个对象(被当做普通函数时，只会看方法体有没有return，没有默认返回对象)</li>
    </ol>
    <h1>Inheritance</h1>
    <p>注意只有函数才有prototype属性，对于实例化的对象来说他们没有prototype属性，每个实例中存在一个[[prototype]]指针指向原型对象，
        在chrome等浏览器中，我们可以通过一个隐藏的__proto__指针查看原型对象</p>
  




        <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>